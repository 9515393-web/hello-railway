<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Админ-карта Захожье</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }

    .leaflet-popup-content-wrapper { border-radius: 14px; }
    .leaflet-popup-content{
      width: 420px !important;
      max-width: 420px !important;
      max-height: 60vh;
      overflow-y: auto;
      font-size: 16px;
      line-height: 1.4;
      white-space: normal !important;
      word-break: normal;
      overflow-wrap: break-word;
    }
    .popup-root{ font-size: 16px; line-height: 1.4; }

    .leaflet-control.custom-buttons{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      border-radius:16px;
      background:rgba(255,255,255,0.9);
      pointer-events:auto;
      z-index:1000;
    }
    .leaflet-control.custom-buttons button{
      min-height:48px;
      padding:10px 14px;
      font-size:16px;
      border-radius:12px;
      cursor:pointer;
    }

    .parcel-label{
      background:transparent !important;
      border:none !important;
      box-shadow:none !important;
      color:#111 !important;
      font-weight:700 !important;
      font-size:12px !important;
      text-shadow:0 0 2px #fff, 0 0 2px #fff;
    }
  </style>
</head>
<body>
<div id="map"></div>

<script>
console.log("MAP SCRIPT LOADED");
console.log("SCRIPT VERSION 2026-02-19 DIAG_STRICT_FIXED");

(function () {
  const params = new URLSearchParams(window.location.search);
  const token = params.get("token");
  if (!token) { alert("⛔ Нет токена доступа"); throw new Error("No token"); }

  const map = L.map("map", { zoomControl: false });
  setTimeout(() => map.invalidateSize(true), 0);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "© OpenStreetMap"
  }).addTo(map);

  fetch(`Zahozhe_final_2026.geojson?token=${encodeURIComponent(token)}`)
    .then(r => { if (!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
    .then(data => {
      console.log("GEOJSON LOADED", data);
      console.log("FEATURES COUNT:", data.features?.length);

      if (!Array.isArray(data.features)) {
        console.error("❌ data.features НЕ массив!", data);
        return;
      }

      console.log("GEOMETRY TYPES SAMPLE:", data.features.slice(0, 10).map(f => f?.geometry?.type));

      let selected = null;

      // Фоновый слой — все границы
      const baseLayer = L.geoJSON(data, {
        interactive: false,
        style: { color: "#ff0000", weight: 1, opacity: 0.35, fill: false }
      }).addTo(map);

      function isPolygonLikeGeometry(feature) {
        const t = String(feature?.geometry?.type || "");
        return t.includes("Polygon");
      }

      function hasFullCadastre(cardFinal) {
        const raw = String(cardFinal || "");
        return /\b\d{2}:\d{2}:\d{7}:\d+\b/.test(raw);
      }

      function extractAreaFromCard(cardFinal) {
        const raw = String(cardFinal || "");
        const m =
          raw.match(/Площадь\s+(?:земельного\s+)?участка\s*([\d.,]+)/i) ||
          raw.match(/Площадь\s+участка\s*([\d.,]+)/i);

        if (!m || !m[1]) return NaN;
        const v = parseFloat(String(m[1]).replace(",", "."));
        return isNaN(v) ? NaN : v;
      }

      function extractPlotNumberFromCard(cardFinal) {
        const raw = String(cardFinal || "");

        const addrLineMatch = raw.match(/^\s*1\.\s*Адрес:\s*([\s\S]*?);/mi);
        const addr = (addrLineMatch ? addrLineMatch[1] : raw)
          .replace(/\s+/g, " ")
          .trim();

        // 1) участок № 179
        let m = addr.match(/\bучасток\s*№\s*(\d+)\b/i);
        if (m && m[1]) return m[1];

        // 2) участок 179 / земельный участок 179
        m = addr.match(/\b(?:земельный\s+)?участок\s+(\d+)\b/i);
        if (m && m[1]) return m[1];

        // 3) уч. N — собираем все
        const all = [];
        const re = /\bуч\.\s*№?\s*(\d+)\b/ig;
        let mm;
        while ((mm = re.exec(addr)) !== null) all.push(mm[1]);

        if (all.length === 0) return "";

        // если есть любой кроме 47 — берём его
        const not47 = all.find(x => x !== "47");
        if (not47) return not47;

        // если только 47 — считаем хвостом адреса
        return "";
      }

      const rejectStats = {
        empty: 0,
        notLand: 0,
        noCad: 0,
        badArea: 0,
        noNum: 0,
        ok: 0
      };

      function isValidLandPlot(cardFinal) {
  const raw = String(cardFinal || "").trim();

  if (!raw) {
    rejectStats.empty++;
    console.log("REJECT empty card_final");
    return false;
  }

  if (!/Земельный участок/i.test(raw)) {
    rejectStats.notLand++;
    console.log("REJECT not land:", raw.slice(0, 80));
    return false;
  }

  if (!hasFullCadastre(raw)) {
    rejectStats.noCad++;
    console.log("REJECT no cadastre:", raw.match(/Кадастровый[^;\n]*/i)?.[0] || raw.slice(0,80));
    return false;
  }

  const area = extractAreaFromCard(raw);
  if (!isFinite(area) || area < 300) {
    rejectStats.badArea++;
    console.log("REJECT bad area:", area, raw.match(/Площадь[^;\n]*/i)?.[0] || raw.slice(0,80));
    return false;
  }

  const num = extractPlotNumberFromCard(raw);
  if (!num) {
    rejectStats.noNum++;
    console.log("REJECT no number:", raw.match(/Адрес[^;\n]*/i)?.[0] || raw.slice(0,80));
    return false;
  }

  rejectStats.ok++;
  return true;
}

      let totalPoly = 0;
      let validCount = 0;

      console.log("ABOUT TO BUILD PARCELS LAYER");

      const parcelsLayer = L.geoJSON(data, {
        interactive: true,
        style: { color: "#ff0000", weight: 2, fillOpacity: 0.20 },

        onEachFeature: (feature, layer) => {
          if (!isPolygonLikeGeometry(feature)) return;

          totalPoly++;

          const rawCard = String(feature?.properties?.card_final || "").trim();
          const valid = isValidLandPlot(rawCard);

          if (!valid) {
            layer.off();
            layer.unbindPopup();
            return;
          }

          validCount++;

          const bodyHtml = rawCard.replace(/\n/g, "<br>");
          layer.bindPopup(
            `<div class="popup-root"><div>${bodyHtml}</div></div>`,
            { maxWidth: 9999, autoPan: true }
          );

          const num = extractPlotNumberFromCard(rawCard);
          if (num && layer.getBounds && layer.getBounds().isValid()) {
            layer.bindTooltip(num, {
              permanent: true,
              direction: "center",
              className: "parcel-label"
            });
          }

          layer.on("click", () => {
            if (selected && selected !== layer) {
              selected.setStyle({ color: "#ff0000", weight: 2, fillOpacity: 0.20 });
            }
            selected = layer;
            layer.setStyle({ color: "#ff0000", weight: 5, fillOpacity: 0.35 });
            layer.openPopup();
          });
        }
      }).addTo(map);

      console.log("POLYGONS:", totalPoly, "VALID INTERACTIVE:", validCount);
      console.log("REJECT STATS:", rejectStats);

      const parcelsBounds = parcelsLayer.getBounds();
      const baseBounds = baseLayer.getBounds();
      const focusBounds = (parcelsBounds && parcelsBounds.isValid()) ? parcelsBounds : baseBounds;

      if (focusBounds && focusBounds.isValid()) {
        map.fitBounds(focusBounds, { padding: [20, 20] });
      } else {
        alert("❌ Не удалось определить границы");
      }

    })
    .catch(err => {
      console.error("Ошибка загрузки карты:", err);
      alert("Ошибка загрузки карты. Проверь соединение или токен.");
    });
})();
</script>
</body>
</html>
