<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>–ê–¥–º–∏–Ω-–∫–∞—Ä—Ç–∞ –ó–∞—Ö–æ–∂—å–µ</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }

    .leaflet-popup-content-wrapper { border-radius: 14px; }
    .leaflet-popup-content{
      width: 420px !important;
      max-width: 420px !important;
      max-height: 60vh;
      overflow-y: auto;
      font-size: 16px;
      line-height: 1.4;
      white-space: normal !important;
      word-break: normal;
      overflow-wrap: break-word;
    }
    .popup-root{ font-size: 16px; line-height: 1.4; }

    .leaflet-control.custom-buttons{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      border-radius:16px;
      background:rgba(255,255,255,0.9);
      pointer-events:auto;
      z-index:1000;
    }
    .leaflet-control.custom-buttons button{
      min-height:48px;
      padding:10px 14px;
      font-size:16px;
      border-radius:12px;
      pointer-events:auto;
      cursor:pointer;
    }

    .parcel-label{
      background:transparent !important;
      border:none !important;
      box-shadow:none !important;
      color:#111 !important;
      font-weight:700 !important;
      font-size:12px !important;
      text-shadow:0 0 2px #fff, 0 0 2px #fff;
    }
  </style>
</head>
<body>
<div id="map"></div>

<script>
console.log("MAP SCRIPT LOADED");
console.log("SCRIPT VERSION 2026-02-18 WORKING_INTERACTIVE_STRICT");

(function () {
  const params = new URLSearchParams(window.location.search);
  const token = params.get("token");
  if (!token) { alert("‚õî –ù–µ—Ç —Ç–æ–∫–µ–Ω–∞ –¥–æ—Å—Ç—É–ø–∞"); throw new Error("No token"); }

  const map = L.map("map", { zoomControl: false });
  setTimeout(() => map.invalidateSize(true), 0);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "¬© OpenStreetMap"
  }).addTo(map);

  fetch(`Zahozhe_final_2026.geojson?token=${encodeURIComponent(token)}`)
    .then(r => { if (!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
    .then(data => {
  console.log("GEOJSON LOADED", data);
  console.log("FEATURES COUNT:", data.features?.length);
  if (!Array.isArray(data.features)) {
  console.error("‚ùå data.features –ù–ï –º–∞—Å—Å–∏–≤!", data);
} else {
  console.log("GEOMETRY TYPES SAMPLE:", data.features.slice(0, 10).map(f => f?.geometry?.type));
}

      
  let selected = null;


      const baseLayer = L.geoJSON(data, {
        interactive: false,
        style: { color: "#ff0000", weight: 1, opacity: 0.35, fill: false }
      }).addTo(map);

      function isPolygonLikeGeometry(feature) {
        const t = String(feature?.geometry?.type || "");
        return t.includes("Polygon"); // –ª–æ–≤–∏—Ç Polygon, MultiPolygon, PolygonZ, MultiPolygonZ
      }


      function hasFullCadastre(cardFinal) {
        const raw = String(cardFinal || "");
        // 47:26:0413001:137
        return /\b\d{2}:\d{2}:\d{7}:\d+\b/.test(raw);
      }

      // ‚úÖ –í–ê–ñ–ù–û: –ª–æ–≤–∏–º –í–°–ï –≤–∞—Ä–∏–∞–Ω—Ç—ã:
      // "–ü–ª–æ—â–∞–¥—å –∑–µ–º–µ–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ 605"
      // "–ü–ª–æ—â–∞–¥—å –∑–µ–º–µ–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ 605"
      // "–ü–ª–æ—â–∞–¥—å —É—á–∞—Å—Ç–∫–∞ 605"
      // "–ü–ª–æ—â–∞–¥—å –∑–µ–º–µ–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ 24.54"
      function extractAreaFromCard(cardFinal) {
        const raw = String(cardFinal || "");

        // –±–µ—Ä—ë–º –ø–µ—Ä–≤—É—é –ø–æ–¥—Ö–æ–¥—è—â—É—é —Ü–∏—Ñ—Ä—É –ø–æ—Å–ª–µ —Å–ª–æ–≤–∞ "–ü–ª–æ—â–∞–¥—å"
        // –¥–æ–ø—É—Å–∫–∞–µ–º "–∑–µ–º–µ–ª—å–Ω–æ–≥–æ" –∏ "–∑–µ–º–µ–ª—å–Ω–æ–≥–æ" –∫–∞–∫ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ
        const m = raw.match(/–ü–ª–æ—â–∞–¥—å\s+(?:–∑–µ–º–µ–ª—å–Ω–æ–≥–æ\s+)?(?:–∑–µ–º–µ–ª—å–Ω–æ–≥–æ\s+)?—É—á–∞—Å—Ç–∫–∞\s*([\d.,]+)/i)
               || raw.match(/–ü–ª–æ—â–∞–¥—å\s+—É—á–∞—Å—Ç–∫–∞\s*([\d.,]+)/i);

        if (!m || !m[1]) return NaN;

        const v = parseFloat(String(m[1]).replace(",", "."));
        return isNaN(v) ? NaN : v;
      }

      // –ù–æ–º–µ—Ä —É—á–∞—Å—Ç–∫–∞:
      // 1) —É—á–∞—Å—Ç–æ–∫ ‚Ññ 179
      // 2) —É—á–∞—Å—Ç–æ–∫ 179 / –∑–µ–º–µ–ª—å–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ 179
      // 3) —É—á. 179 (–ù–û –µ—Å–ª–∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π = 47 ‚Üí –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–∞–∫ —Ö–≤–æ—Å—Ç)
      function extractPlotNumberFromCard(cardFinal) {
        const raw = String(cardFinal || "");

        // –°—Ç—Ä–æ–∫–∞ –∞–¥—Ä–µ—Å–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        const addrLineMatch = raw.match(/^\s*1\.\s*–ê–¥—Ä–µ—Å:\s*([\s\S]*?);/mi);
        const addr = (addrLineMatch ? addrLineMatch[1] : raw)
          .replace(/\s+/g, " ")
          .trim();

        // 1) "—É—á–∞—Å—Ç–æ–∫ ‚Ññ 179"
        let m = addr.match(/\b—É—á–∞—Å—Ç–æ–∫\s*‚Ññ\s*(\d+)\b/i);
        if (m && m[1]) return m[1];

        // 2) "—É—á–∞—Å—Ç–æ–∫ 179" / "–∑–µ–º–µ–ª—å–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ 179"
        m = addr.match(/\b(?:–∑–µ–º–µ–ª—å–Ω—ã–π\s+)?—É—á–∞—Å—Ç–æ–∫\s+(\d+)\b/i);
        if (m && m[1]) return m[1];

        // 3) —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ "—É—á. N"
        const all = [];
        const re = /\b—É—á\.\s*‚Ññ?\s*(\d+)\b/ig;
        let mm;
        while ((mm = re.exec(addr)) !== null) all.push(mm[1]);

        if (all.length === 0) return "";

        const not47 = all.find(x => x !== "47");
        if (not47) return not47;

        // –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ 47 ‚Äî —ç—Ç–æ —Ö–≤–æ—Å—Ç –∞–¥—Ä–µ—Å–∞, –Ω–µ –Ω–æ–º–µ—Ä —É—á–∞—Å—Ç–∫–∞
        return "";
      }

      function isValidLandPlot(cardFinal) {
        const raw = String(cardFinal || "").trim();
        if (!raw) return false;

        // —Ç–æ–ª—å–∫–æ "–ó–µ–º–µ–ª—å–Ω—ã–π —É—á–∞—Å—Ç–æ–∫;"
        if (!/^–ó–µ–º–µ–ª—å–Ω—ã–π —É—á–∞—Å—Ç–æ–∫\s*;/i.test(raw)) return false;

        // —Ç–æ–ª—å–∫–æ –ø–æ–ª–Ω—ã–π –∫–∞–¥–∞—Å—Ç—Ä
        if (!hasFullCadastre(raw)) return false;

        // –ø–ª–æ—â–∞–¥—å >= 300
        const area = extractAreaFromCard(raw);
        if (!isFinite(area) || area < 300) return false;

        // –Ω–æ–º–µ—Ä —É—á–∞—Å—Ç–∫–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å
        const num = extractPlotNumberFromCard(raw);
        if (!num) return false;

        // —Ä–∞–∑—Ä–µ—à–∞–µ–º 47, –µ—Å–ª–∏ –æ–Ω —Ä–µ–∞–ª—å–Ω–æ –Ω–æ–º–µ—Ä —É—á–∞—Å—Ç–∫–∞
        // (—Ö–≤–æ—Å—Ç—ã –º—ã —É–∂–µ –æ—Ç—Ä–µ–∑–∞–µ–º –≤ extractPlotNumberFromCard)


        return true;
      }

      let totalPoly = 0, validCount = 0;

      try {
        console.log("ABOUT TO BUILD PARCELS LAYER");
      } catch (e) {
        console.error("PRE-BUILD ERROR", e);
      }
      
      const parcelsLayer = L.geoJSON(data, {
  interactive: true,
  filter: (feature) => {
  if (!isPolygonLikeGeometry(feature)) return false;

  const rawCard = String(feature?.properties?.card_final || "").trim();
  if (!rawCard) return false;

  const ok = isValidLandPlot(rawCard);

  if (!ok) {
    console.log("‚ùå REJECTED:", rawCard);
  }

  return ok;
},


    // ‚úÖ —Ç–æ–ª—å–∫–æ –í–ê–õ–ò–î–ù–´–ú ‚Äî –ø–æ–ø–∞–ø –∏ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤
    const bodyHtml = rawCard.replace(/\n/g, "<br>");
    layer.bindPopup(
      `<div class="popup-root"><div>${bodyHtml}</div></div>`,
      { maxWidth: 9999, autoPan: true }
    );

    const num = extractPlotNumberFromCard(rawCard);
    if (num && layer.getBounds && layer.getBounds().isValid()) {
      layer.bindTooltip(num, {
        permanent: true,
        direction: "center",
        className: "parcel-label"
      });
    }

    layer.on("click", () => {
      if (selected && selected !== layer) {
        selected.setStyle({ color: "#ff0000", weight: 2, fillOpacity: 0.20 });
      }
      selected = layer;
      layer.setStyle({ color: "#ff0000", weight: 5, fillOpacity: 0.35 });
      layer.openPopup();
    });
  }
}).addTo(map);



      console.log("POLYGONS:", totalPoly, "VALID INTERACTIVE:", validCount);

      const parcelsBounds = parcelsLayer.getBounds();
      const baseBounds = baseLayer.getBounds();
      const focusBounds = (parcelsBounds && parcelsBounds.isValid()) ? parcelsBounds : baseBounds;

      if (focusBounds && focusBounds.isValid()) {
        map.fitBounds(focusBounds, { padding: [20, 20] });
      } else {
        alert("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã");
      }

      const ButtonsControl = L.Control.extend({
        options: { position: "bottomleft" },
        onAdd: function () {
          const container = L.DomUtil.create("div", "leaflet-control custom-buttons");

          const btnZoomIn = L.DomUtil.create("button", "", container);
          btnZoomIn.type = "button";
          btnZoomIn.innerText = "‚ûï –ü—Ä–∏–±–ª–∏–∑–∏—Ç—å";

          const btnZoomOut = L.DomUtil.create("button", "", container);
          btnZoomOut.type = "button";
          btnZoomOut.innerText = "‚ûñ –û—Ç–¥–∞–ª–∏—Ç—å";

          const btnFocus = L.DomUtil.create("button", "", container);
          btnFocus.type = "button";
          btnFocus.innerText = "üîç –ö —É—á–∞—Å—Ç–∫–∞–º";

          const btnOverview = L.DomUtil.create("button", "", container);
          btnOverview.type = "button";
          btnOverview.innerText = "üåç –û–±–∑–æ—Ä";

          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);

          L.DomEvent.on(btnZoomIn, "click", (e) => { L.DomEvent.stop(e); map.flyTo(map.getCenter(), map.getZoom() + 2, { duration: 0.4 }); });
          L.DomEvent.on(btnZoomOut, "click", (e) => { L.DomEvent.stop(e); map.flyTo(map.getCenter(), map.getZoom() - 2, { duration: 0.4 }); });
          L.DomEvent.on(btnFocus, "click", (e) => { L.DomEvent.stop(e); map.fitBounds(focusBounds, { padding: [20, 20], maxZoom: 18 }); });
          L.DomEvent.on(btnOverview, "click", (e) => { L.DomEvent.stop(e); map.fitBounds(focusBounds, { padding: [100, 100] }); });

          return container;
        }
      });

      map.addControl(new ButtonsControl());
    })
    .catch(err => {
      console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç—ã:", err);
      alert("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–ª–∏ —Ç–æ–∫–µ–Ω.");
    });
})();
</script>
</body>
</html>
