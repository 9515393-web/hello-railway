<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>–ê–¥–º–∏–Ω-–∫–∞—Ä—Ç–∞ –ó–∞—Ö–æ–∂—å–µ</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }

    /* POPUP */
    .leaflet-popup-content-wrapper { border-radius: 14px; }
    .leaflet-popup-content{
      width: 420px !important;
      max-width: 420px !important;
      max-height: 60vh;
      overflow-y: auto;
      font-size: 16px;
      line-height: 1.4;
      white-space: normal !important;
      word-break: normal;
      overflow-wrap: break-word;
    }
    .popup-root{ font-size: 16px; line-height: 1.4; }
    .popup-title{ font-size: 18px; font-weight: 700; margin-bottom: 8px; }

    /* BUTTONS */
    .leaflet-control.custom-buttons{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      border-radius:16px;
      background:rgba(255,255,255,0.9);
      pointer-events:auto;
      z-index:1000;
    }
    .leaflet-control.custom-buttons button{
      min-height:48px;
      padding:10px 14px;
      font-size:16px;
      border-radius:12px;
      pointer-events:auto;
      cursor:pointer;
    }

    /* MOBILE */
    @media (max-width:768px){
      .leaflet-popup-content{
        width:90vw !important;
        max-width:90vw !important;
        max-height:60vh !important;
        font-size:12px !important;
        line-height:1.3 !important;
        padding:10px !important;
      }
      .popup-root{ font-size:12px !important; }
      .popup-title{ font-size:14px !important; }
      .leaflet-popup-close-button{ font-size:20px !important; }

      .leaflet-bottom.leaflet-left .leaflet-control.custom-buttons{ margin:10px !important; }
      .leaflet-control.custom-buttons{ gap:6px !important; padding:6px !important; border-radius:10px !important; }
      .leaflet-control.custom-buttons button{
        min-height:32px !important;
        padding:6px 10px !important;
        font-size:12px !important;
        border-radius:8px !important;
      }
    }

    /* LABELS */
    .parcel-label{
      background:transparent !important;
      border:none !important;
      box-shadow:none !important;
      color:#111 !important;
      font-weight:700 !important;
      font-size:12px !important;
      text-shadow:0 0 2px #fff, 0 0 2px #fff;
    }
  </style>
</head>
<body>
<div id="map"></div>

<script>
console.log("MAP SCRIPT LOADED");
console.log("SCRIPT VERSION 2026-02-17 CARD_FINAL_ONLY + WARNING");

(function () {
  const params = new URLSearchParams(window.location.search);
  const token = params.get("token");
  if (!token) { alert("‚õî –ù–µ—Ç —Ç–æ–∫–µ–Ω–∞ –¥–æ—Å—Ç—É–ø–∞"); throw new Error("No token"); }

  const map = L.map("map", { zoomControl: false });
  setTimeout(() => map.invalidateSize(true), 0);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "¬© OpenStreetMap"
  }).addTo(map);

  fetch(`Zahozhe_final_2026.geojson?token=${encodeURIComponent(token)}`)
    .then(r => { if (!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
    .then(data => {
      let selected = null;

      // 1) –ü–æ–¥–ª–æ–∂–∫–∞ ‚Äî –≤—Å–µ –≥—Ä–∞–Ω–∏—Ü—ã –∫—Ä–∞—Å–Ω—ã–µ
      const baseLayer = L.geoJSON(data, {
        interactive: false,
        style: { color: "#ff0000", weight: 1, opacity: 0.35, fill: false }
      }).addTo(map);

      // –ù–æ–º–µ—Ä –¢–û–õ–¨–ö–û –∏–∑ card_final.
      // –í–ê–ñ–ù–û: –ù–ï –∏—Å–ø–æ–ª—å–∑—É–µ–º "‚Ññ 123" –±–µ–∑ —Å–ª–æ–≤ "—É—á/—É—á–∞—Å—Ç–æ–∫", —á—Ç–æ–±—ã –Ω–µ –ª–æ–≤–∏—Ç—å 47 –∏–∑ "47:26:..."
      function extractPlotNumberFromCard(cardFinal) {
        const raw = String(cardFinal || "");
        const m = raw.match(/\b(?:—É—á\.?|—É—á–∞—Å—Ç–æ–∫)\s*‚Ññ?\s*(\d+)\b/i);
        return (m && m[1]) ? m[1] : "";
      }

      function isPolygonLikeGeometry(feature) {
        const t = feature?.geometry?.type;
        return t === "Polygon" || t === "MultiPolygon";
      }
      
      function isRealParcelByCard(cardFinal) {
        const raw = String(cardFinal || "");
       // –ø–æ–ª–Ω—ã–π –∫–∞–¥–∞—Å—Ç—Ä: 47:26:0413001:103
       return /\b\d{2}:\d{2}:\d{7}:\d+\b/.test(raw);
     }
      // –ø–ª–æ—â–∞–¥—å –ø–æ–ª–∏–≥–æ–Ω–∞ –≤ –º¬≤ (–ø—Ä–∏–±–ª–∏–∂—ë–Ω–Ω–æ, –Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞ "–∑–¥–∞–Ω–∏—è vs —É—á–∞—Å—Ç–∫–∏")
function ringAreaM2(ring) {
  if (!ring || ring.length < 3) return 0;

  // —Å—Ä–µ–¥–Ω—è—è —à–∏—Ä–æ—Ç–∞ –¥–ª—è –ø–æ–ø—Ä–∞–≤–∫–∏ cos(lat)
  let latSum = 0;
  for (const p of ring) latSum += p[1];
  const lat0 = (latSum / ring.length) * Math.PI / 180;

  const R = 6371000; // –º
  const toX = (lonDeg) => (lonDeg * Math.PI / 180) * R * Math.cos(lat0);
  const toY = (latDeg) => (latDeg * Math.PI / 180) * R;

  let area2 = 0;
  for (let i = 0; i < ring.length - 1; i++) {
    const x1 = toX(ring[i][0]),     y1 = toY(ring[i][1]);
    const x2 = toX(ring[i+1][0]),   y2 = toY(ring[i+1][1]);
    area2 += (x1 * y2 - x2 * y1);
  }
  return Math.abs(area2) / 2;
}

function featureAreaM2(feature) {
  const g = feature && feature.geometry;
  if (!g) return 0;

  if (g.type === "Polygon") {
    const ring = g.coordinates && g.coordinates[0];
    return ringAreaM2(ring);
  }

  if (g.type === "MultiPolygon") {
    let best = 0;
    const polys = g.coordinates || [];
    for (const poly of polys) {
      const ring = poly && poly[0];
      best = Math.max(best, ringAreaM2(ring));
    }
    return best;
  }

  return 0;
}



    // –§–æ–Ω: —Ä–∏—Å—É–µ–º –í–°–Å, –Ω–æ –ù–ï–ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–û (—á—Ç–æ–±—ã –∑–¥–∞–Ω–∏—è/—Ç–µ—Ö-—Å–ª–æ–∏ –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–ª–∏ –∫–ª–∏–∫–∏)
const parcelsBase = L.geoJSON(data, {
  filter: (feature) => isPolygonLikeGeometry(feature),
  interactive: false,
  style: { color: "#ff0000", weight: 2, fillOpacity: 0.20 }
}).addTo(map);

// –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤: —Ç–æ–ª—å–∫–æ "–Ω–æ—Ä–º–∞–ª—å–Ω—ã–µ —É—á–∞—Å—Ç–∫–∏" (–ø–ª–æ—â–∞–¥—å >= 300 –º¬≤) + –ø–æ–ª–Ω—ã–π –∫–∞–¥–∞—Å—Ç—Ä –≤ card_final
const parcelsLayer = L.geoJSON(data, {
  filter: (feature) => {
    if (!isPolygonLikeGeometry(feature)) return false;

    const area = featureAreaM2(feature);
    if (area > 0 && area < 300) return false; // üî• –ñ–Å–°–¢–ö–û —É–±–∏—Ä–∞–µ–º –∑–¥–∞–Ω–∏—è/–º–µ–ª–æ—á—å

    const rawCard = String(feature?.properties?.card_final || "").trim();
    return isRealParcelByCard(rawCard); // –∫–∞–∫ —É —Ç–µ–±—è –±—ã–ª–æ
  },

  style: { color: "#ff0000", weight: 2, fillOpacity: 0.20 },

  onEachFeature: (feature, layer) => {
    const rawCard = String(feature?.properties?.card_final || "").trim();

    // POPUP ‚Äî —Å—Ç—Ä–æ–≥–æ card_final
    const bodyHtml = rawCard.replace(/\n/g, "<br>");
    layer.bindPopup(`<div class="popup-root"><div>${bodyHtml}</div></div>`, { maxWidth: 9999, autoPan: true });

    // –ü–æ–¥–ø–∏—Å—å ‚Äî –∫–∞–∫ —Ä–∞–Ω—å—à–µ
    const num = extractPlotNumberFromCard(rawCard);
    if (num) {
      try {
        if (layer.getBounds && layer.getBounds().isValid()) {
          layer.bindTooltip(num, { permanent: true, direction: "center", className: "parcel-label" });
        }
      } catch (e) {}
    }

    layer.on("click", () => {
      if (selected && selected !== layer) selected.setStyle({ color: "#ff0000", weight: 2, fillOpacity: 0.20 });
      selected = layer;
      layer.setStyle({ color: "#ff0000", weight: 5, fillOpacity: 0.35 });
      layer.openPopup();
    });
  }
}).addTo(map);

      // 3) –§–æ–∫—É—Å
      const parcelsBounds = parcelsLayer.getBounds();
      const baseBounds = baseLayer.getBounds();
      const focusBounds = (parcelsBounds && parcelsBounds.isValid()) ? parcelsBounds : baseBounds;

      if (!focusBounds || !focusBounds.isValid()) {
        alert("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã");
        return;
      }
      map.fitBounds(focusBounds, { padding: [20, 20] });

      // 4) –ö–Ω–æ–ø–∫–∏
      const ButtonsControl = L.Control.extend({
        options: { position: "bottomleft" },
        onAdd: function () {
          const container = L.DomUtil.create("div", "leaflet-control custom-buttons");

          const btnZoomIn = L.DomUtil.create("button", "", container);
          btnZoomIn.type = "button";
          btnZoomIn.innerText = "‚ûï –ü—Ä–∏–±–ª–∏–∑–∏—Ç—å";

          const btnZoomOut = L.DomUtil.create("button", "", container);
          btnZoomOut.type = "button";
          btnZoomOut.innerText = "‚ûñ –û—Ç–¥–∞–ª–∏—Ç—å";

          const btnFocus = L.DomUtil.create("button", "", container);
          btnFocus.type = "button";
          btnFocus.innerText = "üîç –ö —É—á–∞—Å—Ç–∫–∞–º";

          const btnOverview = L.DomUtil.create("button", "", container);
          btnOverview.type = "button";
          btnOverview.innerText = "üåç –û–±–∑–æ—Ä";

          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.disableScrollPropagation(container);

          function bind(btn, handler) {
            L.DomEvent.on(btn, "click", function (e) {
              L.DomEvent.stop(e);
              handler();
            });
          }

          bind(btnZoomIn, () => map.flyTo(map.getCenter(), map.getZoom() + 2, { duration: 0.4 }));
          bind(btnZoomOut, () => map.flyTo(map.getCenter(), map.getZoom() - 2, { duration: 0.4 }));
          bind(btnFocus, () => {
            map.invalidateSize(true);
            map.fitBounds(focusBounds, { padding: [20, 20], maxZoom: 18 });
          });
          bind(btnOverview, () => {
            map.invalidateSize(true);
            map.fitBounds(focusBounds, { padding: [100, 100] });
          });

          return container;
        }
      });

      map.addControl(new ButtonsControl());
    })
    .catch(err => {
      console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç—ã:", err);
      alert("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–ª–∏ —Ç–æ–∫–µ–Ω.");
    });
})();
</script>
</body>
</html>
